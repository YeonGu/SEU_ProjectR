---
title: 操控小灯
lang: zh-CN
---


# 基础篇最终话: 随心操控的小灯


在这个实验中, 我们将利用前面讲到的UART串口通讯,
让小灯"按着我们的意思"来闪烁. 

:::tip 
在开始本章之前, 请观看视频[串口中断](https://www.bilibili.com/video/BV1bc411J7Tv/?p=10&share_source=copy_web&vd_source=00b9d329964a93c9843f9c524074f948), 尝试利用串口通讯实现: 通过在键盘上输入不同数字, 改变灯的亮灭.
:::

缓冲区与消息队列
----------------

在中断机制与消息处理中, 缓冲区和消息队列是两种常用的数据结构, 它们用于管理和存储中断相关的数据.

### 缓冲区

缓冲区是内存中的一块区域, 用于临时存储数据. 在中断上下文中,
缓冲区通常用于存储从硬件设备(如储存介质, 键盘等)传入的数据,
或者存储准备发送到硬件设备的数据. 当硬件设备准备好接收或发送数据时,
它会发出中断信号, 操作系统将数据从设备的缓冲区复制到内核的缓冲区,
或者从内核的缓冲区复制到设备的缓冲区.

一种特殊的缓冲区叫环形缓冲区, 它在数据结构上首尾相连, 形成一个环状,
因此得名(实际储存在内存中当然还是线性的).
环形缓冲区环形缓冲区在创建时被分配为一个固定大小的数组,
即它有一定的容量限制. 它用两个指针来跟踪数据的写入和读取位置.
写指针指示下一个数据应该被写入的位置,
而读指针指示下一个数据应该被读取的位置. 如果写指针追上读指针,
新的数据将覆盖旧的数据, 或者也可以定义一些其他的处理策略.
但普通的线性缓冲区写满后就无法再写入了. 相比普通线性缓冲区,
环形缓冲区一个很大的优势就是数据被写入和读取时, 不需要移动其他数据,
大大减少了内存操作的次数.

### 消息队列

消息队列是一种数据结构, 它允许消息按顺序存储和检索. 在中断机制中,
消息队列用于管理中断请求和中断处理程序的通信. 当一个中断发生时,
它可以向消息队列中添加一个消息, 该消息包含了中断的详细信息.
操作系统或中断服务例程可以按顺序处理消息队列中的消息,
确保每个中断都得到适当的响应.

消息队列的好处是它提供了一种有序的方式来处理多个中断,
可以确保高优先级的中断得到优先处理, 并且不会因为低优先级的中断而延迟.

指令协议
--------

在更复杂的应用场合, 我们会接触到不同的指令协议.
它们规定了传输数据的格式和规范. 例如一个指令的起始和结束符,
以及各个指令中, 哪几个byte代表什么样的数据.
在这里我们就为板子上的LED规定一个属于我们自己的指令协议.

为了方便解析指令, 我们使用反斜杠和分号作为指令的起始和结束符.
指令的内容分为两部分: `identifier` 和 `dest` ,
分别代表操作的类型和操作的对象. 目前我们定义两个 `identifier`, `LTON`
开灯, `LTOFF` 关灯.
``` SHELL
\LTON 1;
\LTOFF 3;
```
在用串口发出上述指令之后, 分别会见到LED 1亮和LED 3灭的现象.
如果遇到了未知指令, 则STM32使用UART回复: `Unknown identifier.`

创建工程和获取框架代码
----------------------

请按照之前的方法创建工程, 并且使用CubeMX初始化好UART,
GPIO等等外设和相应的中断设置.

工程创建完毕后, 在 `src` 文件夹中下载需要的框架代码.
你可以使用以下任何一种方法:

-   使用git(推荐):
```shell
git clone https://github.com/YeonGu/ex1.git
```
-   直接下载: 访问 <https://github.com/YeonGu/ex1>, 通过Code -\>
    Download Zip的方式下载代码, 然后解压到src/文件夹中.
-   任何能够把GitHub上的代码偷下来的方法.

## 框架代码讲解

## 必做 & 验收内容

修改历史
--------

:::info 修改历史
2024/3 完成框架代码. (顾雨杭)
:::